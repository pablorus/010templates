//------------------------------------------------
//--- 010 Editor v2.0 Binary Template
//
//      File: DjVu.bt
//    Author: pablorus
//   Version: 1.0
//   Purpose: Parse DjVu files.
//  Category: image
// File Mask: *.djvu
//  ID Bytes: 41 54 26 54 46 4F 52 4D //AT&TFORM
//   History:  
//   1.0   Initial release.
//
// More information available at:
//  https://en.wikipedia.org/wiki/DjVu
//------------------------------------------------

// Typedefs for the djvu file 

// Usual chunk header - 4 chars
typedef char ID[4];

// Convert byte array to INT24-value
int _int24(byte data[3]){
    local int result = data[0];
    result <<= 8;
    result |= data[1];
    result <<= 8;
    result |= data[2];
    return result; 
}

// Basic chunk structure
typedef struct 
{
    SetBackColor( cLtAqua );
    ID     chunkID;
    BigEndian();
    uint length;
    char data[length];
} CHUNK;


typedef struct
{
    BitfieldDisablePadding();
    char hasname:1;
    char hastitle:1;
    char flags:6;
} BZZ_flag;



typedef struct 
{
  byte flag:1;
  byte version:7;
} FLAG_VERSION;

typedef struct 
{
    SetBackColor( cLtGreen );
    ID     chunkID;
    BigEndian();
    uint length;
    FLAG_VERSION fv <name="Flag/Version byte", comment=flagInfo>;
    ushort nFiles <comment="Number of component files">;

    local uint data_length = fv.flag?(length - 3 - nFiles*4):(length - 3);

    if (fv.flag)
        uint offsets[nFiles] <comment="Offsets of each of the component file">; 

    char data[data_length];
} DIRM_CHUNK;


typedef struct 
{
    // This chunk should be next to DIRM
    SetBackColor( cLtBlue );
    ID  chunkID;
    BigEndian();
    uint length;
    char data[length];
} NAVM_CHUNK;

typedef struct 
{
    BigEndian();
    ushort width;
    ushort heigth;
    byte   minorVersion;
    byte   majorVersion;
    ushort dpi;
    byte gamma;
    byte flags;
} INFO_CHUNK_DATA;

typedef struct 
{   
    SetBackColor( cLtPurple );
    ID     chunkID;
    BigEndian();
    uint length;    
    INFO_CHUNK_DATA data;
} INFO_CHUNK;


typedef struct 
{   
    SetBackColor( cLtPurple );
    ID     chunkID;
    BigEndian();
    uint length;    
    char str[length] <comment="convertUtf8">; 
//    local char ustr[length] = ConvertString(str, CHARSET_ASCII, CHARSET_ANSI);
//    Printf("link=%s\n", ustr);
} INCL_CHUNK;

typedef struct 
{   
    ID     chunkID;
    BigEndian();
    uint length;    
    char data[length]; 
} Sjbz_CHUNK;

typedef struct 
{   
    SetBackColor( cLtPurple );
    ID     chunkID;
    BigEndian();
    uint length;    
    char data[length]; 
} FG44_CHUNK;

typedef struct 
{   
    SetBackColor( cLtPurple );
    ID     chunkID;
    BigEndian();
    uint length;    
    char data[length]; 
} BG44_CHUNK;

typedef struct 
{   
    SetBackColor( cLtPurple );
    ID     chunkID;
    BigEndian();
    uint length;    
    char data[length]; 
} TXTz_CHUNK;

typedef struct 
{   
    SetBackColor( cLtPurple );
    ID     chunkID;
    BigEndian();
    uint length;    
    char data[length]; 
} ANTz_CHUNK;

typedef struct 
{   
    SetBackColor( cLtPurple );
    ID     chunkID;
    BigEndian();
    uint length;    
    char data[length]; 
} FGbz_CHUNK;

// Color JB2 data
typedef struct 
{   
    SetBackColor( cLtPurple );
    ID     chunkID;
    BigEndian();
    uint length;    
    char data[length]; 
} Djbz_CHUNK;

local ID tempID;

typedef struct 
{
    ID     chunkID;
    BigEndian();
    uint length;
    local uint m_pos = FTell();
    ID     type;
//    char data[length - 4];
    while( FTell() - m_pos < length ){
       if (ReadByte() == 0)
          FSeek(FTell() + 1);
        ReadBytes(tempID, FTell(), 4);
        switch (tempID) {
//         case "FORM": FORM_CHUNK subchunk <comment=chunkID>;
//                      Printf("-- FORM --\n"); break;
         case "NAVM": CHUNK subchunk <comment=chunkID>;
                      Printf("-- NAVM --\n"); break;
         case "TXTa": CHUNK subchunk <comment=chunkID>;
                      Printf("-- TXTa --\n"); break;
         case "TXTz": TXTz_CHUNK subform <comment="Text data (BZZ compressed)">; break;
         case "ANTa": CHUNK subchunk <comment=chunkID>;
                      Printf("-- ANTa --\n"); break;
         case "ANTz": ANTz_CHUNK subform <comment="Annotation data (BZZ compressed)">; break;
         case "CIDa": CHUNK subchunk <comment=chunkID>;
                      Printf("-- CIDa (Coder Information) --\n"); break;
         case "Djbz": Djbz_CHUNK subform <comment="Shared shape table. JB2 dictionary data">; break;
         case "Sjbz": Sjbz_CHUNK subform <comment="single arithmetically encoded data stream">; break;
         case "FG44": FG44_CHUNK subform <comment="foreground">; break;
         case "BG44": BG44_CHUNK subform <comment="background">; break;
         case "TH44": CHUNK subchunk <comment=chunkID>;
                      Printf("-- TH44 --\n"); break;
         case "WMRM": CHUNK subchunk <comment=chunkID>;
                      Printf("-- WMRM --\n"); break;
         case "FGbz": FGbz_CHUNK subform <comment="Color JB2 data">; break;
         case "INFO": INFO_CHUNK subform <comment="info">; break;
         case "INCL": INCL_CHUNK subform <comment="include">; break;
         case "BGjp": CHUNK subchunk <comment=chunkID>;
                      Printf("-- BGjp --\n"); break;
         case "FGjp": CHUNK subchunk <comment=chunkID>;
                      Printf("-- FGjp --\n"); break;
         case "Smmr": CHUNK subchunk <comment=chunkID>;
                      Printf("-- Smmr --\n"); break;
         default: 
                CHUNK subchunk <comment=chunkID>;
                Printf("Unknown chunk: %s\n", subchunk.chunkID);
        }
    }
} FORM_CHUNK;

typedef struct 
{
    ID     chunkID;
    BigEndian();
    uint length;
    local uint pos = FTell();
    ID  type;
    while( FTell() - pos < length ){
            // Printf("current pos = %x, m_pos=%x, len=%x\n", FTell(), m_pos, wrap.length);
        if (ReadByte() == 0)
                FSeek(FTell() + 1);
        ReadBytes(tempID, FTell(), 4);
        switch(tempID){
         case "FORM": FORM_CHUNK subform <comment=formChunkInfo>;
                      break;
         case "DIRM": DIRM_CHUNK subchunk <comment="Directory Chunk">;
                      Printf("-- DIRM --\n"); break;
         case "NAVM": NAVM_CHUNK subchunk <comment="Document Outline Chunk">;
                      Printf("-- NAVM --\n"); break;

         default: 
                CHUNK subchunk <comment=chunkID>;
                Printf("m Unknown chunk: %s\n", subchunk.chunkID);

        }
    }
} MAIN_FORM;

string IDInfo( ID &id )
{
  local char buf[20];  
  SPrintf(buf, "%s", id);
  return buf;
}


string flagInfo( FLAG_VERSION &fv )
{
  local char buf[20];  
  string flag = fv.flag?"bundled":"indirect"; 
  SPrintf(buf, "%s file, version: %d", flag, fv.version);
  return buf;
}

string formChunkInfo( FORM_CHUNK &chunk )
{
  local char buf[20];  
  SPrintf(buf, "%s:%s", chunk.chunkID, chunk.type);
  return buf;
}     


string chunkID( CHUNK &subchunk )
{
  local char buf[20];  
  SPrintf(buf, "Chunk: %s", subchunk.chunkID);
  return buf;
}     

string mainFormID( MAIN_FORM &form )
{
  local char buf[20];  
  SPrintf(buf, "%s:%s", form.chunkID, form.type);
  return buf;
}     


string convertUtf8( char str[] )
{
  return ConvertString(str, CHARSET_ASCII, CHARSET_ANSI);;
}     


// Stores the DIRM information
typedef struct 
{
    uchar flags_version;
    ushort nFiles;
    if (flags_version & 0x80)
        uint offsets[nFiles];
    
/*    BitfieldDisablePadding();
    INT24 sizes[nFiles];
    BZZ_flag flags[nFiles];
    string ID0; */
} DIRMCHUNK;

// Stores the DIRM BZZ info
typedef struct 
{
    uchar flags_version;
    ushort nFiles;
    if (flags_version & 0x80)
        uint offsets[nFiles];

} DIRM_BZZ_data;

local int bitcount;
local unsigned char _byte = 0;
local unsigned char scount = 0;
local unsigned char delay = 25;
local unsigned int  a = 0;
local unsigned int  code;
local unsigned int  fence;
local unsigned int  subend = 0;
local unsigned int  buffer = 0xffffff;
local unsigned int  nrun = 0;

void preload()
{
  local int pos = FTell();  
  while (scount<=24)
    {
      // byte read_byte;  
      _byte = ReadByte();
      pos = FTell();  
      FSeek(pos + 1);
   
      buffer = (buffer<<8) | _byte;
      scount += 8;
    }
}


void decoder_init(){
  a = 0;
  /* Read first 16 bits of code */
  _byte = ReadByte();
      FSeek(FTell() + 1);
  code = (_byte<<8);

  _byte = ReadByte();
      FSeek(FTell() + 1);
  code = code | _byte;

  /* Preload buffer */
  delay = 25;
  scount = 0;
  preload();
  /* Compute initial fence */
  fence = code;
  if (code >= 0x8000)
    fence = 0x7fff;
}

// machine independent ffz
local char ffzt[256];

void init_ffzt(){
 local int i=0;
 local int j=0;   
 while (i<256)
    {
      ffzt[i]=0;
      j=i;
      while(j&0x80){  
        ffzt[i] += 1;
        j <<= 1;
      }
      i++;  
    }
}

init_ffzt();

int ffz(unsigned int x)
{
    return (x>=0xff00) ? (ffzt[x&0xff]+8) : (ffzt[(x>>8)&0xff]);
}

int decode_sub_simple(int mps, unsigned int z)
{
//  Printf("z=%d, code=%d, scount=%d\n", z, code, scount);
  /* Test MPS/LPS */
  if (z > code)
    {
      /* LPS branch */
      z = 0x10000 - z;
      a = a + z;
      code = code + z;
      /* LPS renormalization */
      local int shift = ffz(a);
      scount -= shift;
      a = (unsigned short)(a << shift);
    //  Printf("z=%d, shift=%d code=%d scount=%d\n", z, shift, code, scount);
//      code = (unsigned short)(code<<shift);
      code = ((buffer>>scount));
 //& ((1<<shift)-1));
// | ((buffer>>scount) & ((1<<shift)-1));
/*
#ifdef ZPCODEC_BITCOUNT
      bitcount += shift;
#endif
*/
      if (scount < 16) 
            preload();
      /* Adjust fence */
      fence = code;
      if (code >= 0x8000)
        fence = 0x7fff;
      return mps ^ 1;
    }
  else
    {
      /* MPS renormalization */
      scount -= 1;
      a = (unsigned short)(z<<1);
      code = (unsigned short)(code<<1) | ((buffer>>scount) & 1);
/*
#ifdef ZPCODEC_BITCOUNT
      bitcount += 1;
#endif
*/
      if (scount<16) 
            preload();
      /* Adjust fence */
      fence = code;
      if (code >= 0x8000)
        fence = 0x7fff;
      return mps;
    }
}

int decoder()
{
  return decode_sub_simple(0, 0x8000 + (a>>1));
}

int decode_raw(int bits)
{
  decoder_init();  
  local int b = 0;
  local int n = 1;
  local int m = (1 << bits);
  Printf("n=%d, m=%d, bits=%d\n", n, m, bits);
  while (n < m)
    {
      b = decoder();
      n = (n<<1) | b;
     // Printf("n=%d, b=%d\n", n, b);    
    }
  return n - m;
}


// Define the headers

SetBackColor( cLtPurple );
ID header<comment="DjVu-file header should be AT&T">;

// Check for valid header
if( header != "AT&T")
{
    Warning( "File is not a valid DjVu file. Template stopped." );
    return -1;
}


MAIN_FORM form <comment=mainFormID>;

   // ID file_type;

//    switch( file_type )
//    {
//        case "DJVM":
//            Printf("Multipage document\n");
//            SetBackColor( cLtGray );
//            DIRM_CHUNK dirm<comment="Directory Chunk">;
//            SetBackColor( cLtBlue );
//            //char   dirm_data[dirm.length];
//             DIRM_CHUNK dirm_data;
//            local int raw_len = decode_raw(24);
//            Printf("raw_len=%x", raw_len);
           // uchar data[dirm.length];
    /*        switch( tag )
            {
                case "DIRM": 
                    DIRM_Unencoded_data unenc_data;
                    break;
                default:
                    // Unknown chunk
                    break;

            }
*/
//            break;
//        default:
//            // Unknown chunk
//            break;
//    }
